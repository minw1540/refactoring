# 6.9 여러 함수를 클래스로 묶기

## 6.9 목표

as-is

```
function base(aReading) {...}
function taxableCharge(aReading) {...}
function calculateBaseCharge(aReading) {...}
```

to-be

```
class Reading {
  base(){...}
  taxableCharge() {...}
  calculateBaseCharge() {...}
}
```

## 배경
- 클래스는 데이터와 함수를 하나의 공유 환경으로 묶은후, 다른 프로그램 요소와 어우러질 수 있도록 그중 일부를 외부에 제공한다.
- 클래스는 객체 지향 언어의 기본인 동시에 다른 패러다임 언어에도 유용하다.

### 여러 함수를 클래스로 묶기의 장점
- 클로스로 묶으면 이 함수들이 공유하는 공통 환경을 더 명확하게 표현할 수 있다.
- 각 함수에 전달되는 인수를 줄여서 객체 안에서의 함수 호출을 간결하게 만들 수 있다.
- 객체를 시스템의 다른 부분에 전달하기 위한 참조를 제공할 수 있다.
- 클라이언트가 객체의 핵심 데이터를 변경할 수 있고, 파생 객체들을 일관되게 관리할 수 있다.

### 함수를 객체처럼 패턴
- 클래스를 지원하지 않는 언어를 사용할때 사용되는 패턴
- 일급 함수와 클로저 지원 필요 (일급 함수와 클로저를 이용하여 구성)
- https://martinfowler.com/bliki/FunctionAsObject.html

```
function createPerson(name) {
  let birthday;
  return {
    name: () => name,
    setName: (aString) => name = aString,
    birthday: () => birthday,
    setBirthday: (aLocalDate) => birthday = aLocalDate,
    age: age,
    canTrust: canTrust,
  };
  function age() {
    return birthday.until(clock.today(), ChronoUnit.YEARS);
  }
  function canTrust() {
    return age() <= 30;
  }
}

// 사용
const kent = createPerson("kent");
kent.setBirthday(LocalDate.parse("1961-03-31"));
const youngEnoughToTrust = kent.canTrust();
```

## 절차 

1. 함수들이 공유하는 공통 데이터 레코드를 캡슐화 한다.
 - 공통 데이터가 레코드 구조로 묶여 있지 않다면 사전 작업으로 ***매개변수 객체 만들기 진행(6.8절)***
2. 공통 레코드를 사용하는 함수 각각을 새 클래스로 옮긴다 (함수 옮기기 8.1절)
 - 공콩 레코드의 맴버는 함수 호출문의 인수 목록에서 제거
3. 데이터를 조작하는 로직들은 함수로 추출해서(6.1절) 새 클래스로 옮긴다.

## 예시
수돗물 처럼 차 계량기를 읽어서 측정값을 기록하는 로직

> 1번 클라이언트

```
const aReading = acquireReading();
const baseCharge = baseRate(aReading.month, aReading.year) * aReading.quantity;
```

> 2번 클라이언트

```
const aReading = acquireReading();
const base = (baseRate(aReading.month, aReading.year) * aReading.quantity)
const taxableCharge = Math.max(0, base - taxThreshold(aReading.year))
```

> 3번 클라이언트

```
const aReading = acquireReading();
const basicChargeAmount = calculateBaseCharge(aReading);

/**
 * [기본 요금 계산 함수]
 * 1번 클라이언트, 2번 클라이언트에 공통된 계산식 존재
 */
function calculateBaseCharge(aReading) {
  return baseRate(aReading.month, aReading.year) * aReading.quantity;
}
```

1번 클라이언트와 2번 클라이언트의 공동된 계산식을 함수로 추출(6.1절)한 것과 같은 3번 클라이언트의 `calculateBaseCharge()` 가 존재한다.

1번 클라이언트와 2번 클라이언트도 해당 함수를 사용할 수 있지만, 최상위 함수로 두면 못 보고 지나치기 쉬운 문제가 발생한다.

-> 함수를 데이터 처리 코드 가까이에 두기 위한 데이터를 클래스로 변환 한다.

### 1. 함수들이 공유하는 공통 데이터 레코드를 캡슐화 한다.
레코드를 클래스로 변환하기 위해 레코드를 캡슐화(7.1절) 한다.

```
class Reading {
  constructor(data) {
    this._customer = data.customer;
    this._quantity = data.quantity;
    this._month = data.month;
    this._year = data.year;
  }

  get customer() {
    return this._customer;
  }

  get customer() {
    return this._quantity;
  }

  get month() {
    return this._month;
  }

  get year() {
    return this._year;
  }
}
```

### 2. 공통 레코드를 사용하는 함수 각각을 새 클래스로 옮긴다 (함수 옮기기 8.1절)
새 클래스를 사용하려면 데이터를 얻자마자 객체로 만들어야 한다.

> 3번 클라이언트

```
const rawReading = acquireReading();
const aReading = new Reading(rawReading);
const basicChargeAmount = calculateBaseCharge(aReading);

```

이미 만들어져 있는 `calculateBaseCharge()`를 새로 만든 클래스로 옮긴다.(함수 옮기긱 8.1절)

> Reading 클래스

```
class Reading {
  constructor(data) {...}
  
  //사전에 만든 getter 들...

  get calculateBaseCharge() {
    return baseRate(this._month, this._year) * this._quantity;
  }
}
```

> 3번 클라이언트

```
const rawReading = acquireReading();
const aReading = new Reading(rawReading);
const basicChargeAmount = aReading.calculateBaseCharge;
```

`calculateBaseCharge`를 조금 더 명확한 이름으로 변경한다. (함수 이름 바꾸기 6.5절)

> Reading 클래스

```
class Reading {
  constructor(data) {...}
  
  //사전에 만든 getter 들...

  get baseCharge() {
    return baseRate(this.month, this.year) * this.quantity;
  }
}
```

> 3번 클라이언트

```
const rawReading = acquireReading();
const aReading = new Reading(rawReading);
const basicChargeAmount = baseCharge;
```

`baseCharge`로 이름을 변경하면 Reading 클래스를 사용하는 클라이언트는 baseCharge가 필드인지, 계산된 값을 return하는 함수 호출인지 구분 할 수 없으며, 이는 ***단일 접근 원칙***을 따르므로 권장하는 방식이다.

#### 단일 접근 원칙이란? (Uniform Access Principle) 
이 원칙의 핵심은 person 객체가 있고, 그 객체의 나이값을 알고 싶을 때 나이가 객체 내의 필드에 저장되어 있든 계산된 값이든 상관없이 같은 방식으로 접근해야 한다는 것이다. 이는 person 객체를 사용하는 클라이언트가 나이가 저장된 것인지 계산된 것인지 신경 쓸 필요도, 알 필요도 없어야 한다는 것을 의미한다.


1번, 2번 클라이언트도 Reading 클래스를 사용할 수 있도록 변경해준다.

> 2번 클라이언트

```
const rawReading = acquireReading();
const aReading = new Reading(rawReading);
const taxableCharge = Math.max(0, aReading.baseCharge - taxThreshold(aReading.year))
```

### 3. 데이터를 조작하는 로직들은 함수로 추출해서(6.1절) 새 클래스로 옮긴다.
세금을 부과할 소비량을 계산하는 코드를 함수로 추출(6.1절)한다.

```
function taxableChargeFn(aReading) {
  return Math.max(0, aReading.baseCharge - taxThreshold(aReading.year))
}
```

추출한 함수를 클라이언트에 적용한다.


> 3번 클라이언트

```
const rawReading = acquireReading();
const aReading = new Reading(rawReading);
const taxableCharge = taxableChargeFn(aReading);
```

완벽히 작동한다면, 추출한 함수를 Reading 클래스로 옮긴다 (함수 옮기기 8.1절)

> Reading 클래스

```
class Reading {
  constructor(data) {...}
  
  //사전에 만든 getter 들...

  get taxableCharge() {
    return Math.max(0, this.baseCharge - taxThreshold(this.year))
  }
}
```

> 3번 클라이언트

```
const rawReading = acquireReading();
const aReading = new Reading(rawReading);
const taxableCharge = aReading. taxableCharge;
```

## 완성
- 파생 데이터를 모두 필요한 시점에 계산하게 되었다. -> 저장된 데이터를 갱신하더라도 문제 없다. 
- 프로그램의 다른 부분에서 데이터를 갱신할 가능성이 높을때는 클래스로 묶어 사용하면 도움이 된다.


# 2.1 리팩터링 정의

리팩터링 이란 용어는 명사로도 쓸 수 있고, 동사로도 쓸 수 있다.

> 리팩터링 : [명사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 
> 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법


앞 장에서 본 함수 추출하기 (6.1절)와 조건부 로직을 다형성으로 바꾸기 (10.4절) 처럼 이름 붙은 리팩터링 기법들이 

이 정의에 해당한다.

> 리팩터링(하다) : [동사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 
> 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.


많은 사람이 코드를 정리하는 작업을 모조리 '리팩터링' 이라고 표현하고 있는데,

앞에서 제시한 정의를 따르면 특정한 방식에 따라 코드를 정리하는 것만이 리팩터링이다.

리팩터링은 결국 동작을 보존하는 작은 단계들을 거쳐 코드를 수정하고, 이러한 단계들을 순차적으로 연결하여

큰 변화를 만들어 내는 일이다.

개별 리팩터링은 그 자체로 아주 작을 수도 있고, 작은 단계 여러 개가 합쳐진 모습일 수도 있다.

**리팩터링하는 동안에는 코드가 항상 정상 작동하기 때문에 전체 작업이 끝나지 않았더라도 언제든 멈출 수 있다.**

즉, 누군가 '리팩터링하다가 코드가 깨져서 며칠이나 고생했다' 라고 한다면, 십중팔구 리팩터링 한것이 아니다.

<br/>

코드베이스를 정리하거나 구조를 바꾸는 모든 작업을 '재구성' 이라는 포괄적인 용어로 표현한다면.

리팩터링은 재구성 중 특수한 한 형태로 생각할 수 있다.

한 번에 바꿀 수 있는 작업을 수많은 단계로 잘게 나눠서 작업하는 모습을 처음 접하면 리팩터링하는 것이

오히려 히 효율적이라고 생각할 수 있다.

하지만 이렇게 잘게 나눔으로써 오히려 작업을 더 빨리 처리할 수 있다.

단계들이 체계적으로 구성되어 있기도 하고, 무엇보다 디버깅하는 데 시간을 뺏기지 않기 때문이다.

<br/>

리팩터링을 정의할 때 '겉보기 동작' 이란 표현을 썼다. 

리팩터링하기 전과 후의 코드가 똑같이 동작해야 한다는 뜻이다.

하지만, 함수 추출하기 (6.1절) 를 거치면 콜스택이 달라져서 성능이 변항수 있다.

그렇지만 사용자 관점에서는 달라지는 점이 없어야 한다.

특히, 함수 선언 바꾸기 (6.5절), 함수 옮기기 (8.1절) 같은 리팩터링을 하면 모듈의 인터페이스가

변경될 때가 많다. 

또한, 이와 같은 이유로 **리팩터링 과정에서 발견된 버그는 리팩터링 후에도 그대로 남아 있어야 한다.**

(아무도 발견하지 못한 숨은 버그는 수정해도 괜찮다.)

<br/>

리팩터링은 성능 최적화와 비슷하다. 둘 다 코드를 변경하지만 프로그램의 전반적인 기능은 그대로 유지 된다.

하지만 목적은 다르다. **리팩터링의 목적은 코드를 이해하고 수정하기 쉽게 만드는 것이다.**

프로그램 성능은 좋아질 수도, 나빠질 수도 있다. 반면 성능 최적화는 오로지 속도 개선에만 신경쓴다.

# 2.2 두 개의 모자

소프트웨어를 개발할 때 목적이 '기능 추가' 인지, '리팩터링' 인지 명확히 구분해야 한다.

이를 켄트 벡은 '두 개의 모자'에 비유했다.

기능을 추가할 때는 기능 추가 모자를 쓴 다음 기존 코드는 절대 건드리지 않고 새 기능을 추가하기만 하면 된다.

진척도는 테스트를 추가해서 통과하는지 확인하는 방식으로 측정한다.

<br/>

리팩터링할 때는 리팩터링 모자를 쓴 다음 기능 추가는 절대로 하지 않고 오로지 코드 재구성에만 전념한다.

테스트 또한 새로 만들지 않으며, 부특이 인터네이스를 변경해야 할 때만 기존 테스트를 수정한다.

<br/>

소프트웨어를 개발하는 동안 두 모자를 자주 바꿔 쓰게 된다.

새 기능을 추가하다 보면 코드 구조를 바꿔야 작업하기 훨씬 쉽겠다는 생각이 들기도 하는데,

그러면 잠시 모자를 바꿔 쓰고 리팩터링을 진행한다.

코드 구조가 어느 정도 개선되면 다시 모자를 바꿔 스고 기능 추가를 이어간다.

전체적인 작업 시간이 짦다 해도, 항상 내가 쓰고 있는 모자가 무엇인지와 그에 따른 

미묘한 작업 방식의 차이를 분명하게 인식해야 한다.

# 2.3 리팩터링하는 이유

리팩터링은 코드를 건강한 상태로 유지하는 데 큰 도움이 된다.

## 리팩터링하면 소프트웨어 설계가 좋아진다

리팩터링하지 않으면 소프트웨어의 내부 설계 (아키텍처)가 썩기 쉽다.

아키텍처를 충분히 이해하지 못한 채 단기 목표만을 위해 코드를 수정하다 보면 기반 구조가 무너지기 쉽다.

이러한 상태가 지속된다면 코드만 보아서는 설계를 파악하기 어려워지고 

설계를 유지하기 어려워 설계의 부패 속도가 더욱 빨라진다. 리팩터링은 코드의 구조를 지탱해줄 수 있다.

<br/>

같은 일을 하더라도 설계가 나쁘면 코드가 길어지기 십상이다.

사실상 같은 일을 하는 코드가 여러 곳에서 나타날 수 있기 때문이다. 그래서 중복 코드 제거는 설계 개선 작업의 중요한 한 축을 차지한다.

코드량을 줄인다고 시스템이 빨라지는 것은 아니다. 프로그램의 용량이 속도에 영향을 주는 경우는 별로 없다.

하지만, **코드량이 줄면 수정하는 데 드는 노력은 크게 달라진다. 코드가 길수록 실수 없이 수정하기 어려워진다.** 

**이해해야 할 코드량도 늘어난다.**

비슷한 일을 하는 코드가 산재해 있다면 한 부분만 살짝 바꿔서는 시스템이 예상대로 작동하지 않을 수 있다. 

반면, **중복 코드를 제거하면 모든 코드가 언제나 고유한 일을 수행함을 보장할 수 있다.**

## 리팩터링하면 소프트웨어를 이해하기 쉬워진다.

프로그래밍은 여러 면에서 마치 컴퓨터와 대화하는 것과 같다. 코드를 작성하면, 컴퓨터는 정확히 시킨 대로 반응한다.

그래서 컴퓨터에게 시키려는 일과 이를 표현한 코드의 차이를 최대한 줄여야한다. 

결국 프로그래밍은 내가 원하는 바를 정확히 표현하는 일이다.

하지만, 내 소스 코드를 컴퓨터만 사용하는것이 아니다. 누군가 내 코드를 수정하고자 일게 될 수도 있다.

프로그램을 동작시키는 데만 신경 쓰다 그 코드를 다룰 개발자를 배려하지 못하는 경우가 있다.

코드를 이해하기 쉽게 만들려면 일하는 리듬에 변화를 줘야 한다.

리팩터링은 코드가 더 잘 읽히게 도와주며, 코드의 목적이 더 잘 드러나게 

** 다시 말해 내 의도를 더 명확하게 전달하도록 개선할 수 있다.**

## 리팩터링하면 버그를 쉽게 찾을 수 있다.

코드를 이해하기 쉽다는 말은 버그를 찾기 쉽다는 말이기도 하다.

리팩터링하면 코드가 하는 일을 깊이 파악하게 되면서 새로 깨달은 것을 곧바로 코드에 반영하게 된다.

리팩터링은 견고한 코드를 작성하는 데 무척 효과적이다.

## 리팩터링하면 프로그래밍 속도를 높일 수 있다.

리팩터링하면 코드 개발 속도를 높일 수 있다.

리팩터링은 우선 품질을 높일 수 있다. 내부 설계와 가독성이 개선되고 버그가 줄어든다. 이 점들은 모두 품질 향상에 직결된다.

또한 개발 초기에는 진척이 빨랐지만 새로운 기능을 추가할수록 기존 코드베이스에 잘 녹여낼 방법을 찾는 시간과

기능 추가 이후 버그가 발생할 수 있는 상황을 줄여준다.

<br/>

내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 지점과 어떻게 고칠지를 쉽게 찾을 수 있다.

모둘화가 잘 되어 있으면 전체 코드베이스 중 작은 일부만 이해하면 된다.

코드가 명확하면 버그를 만들 가능성도 줄고, 버그를 만들더라도 디버깅하기 쉽다.

내부 품질이 뛰어난 코드베이스는 새 기능 구축을 돕는 견고한 토대가 된다.

이 효과를 **설계 지구력 가설** 이라고 부른다.

내부 설계에 심혈을 기울이면 소프트웨어의 지구력이 높아져서 빠르게 개발할 수 있는 상태를 더 오래 지속할 수 있다.

# 2.4 언제 리팩터링해야 할까?

> 리팩터링 3의 법칙
> 
> 1. 처음에는 그냥 한다.
> 2. 비슷한 일을 두 번째로 하게 되면(중복이지만), 일단 계속 진행한다.
> 3. 비슷한 일을 세 번째 하게 되면 리팩터링한다.


## 준비를 위한 리팩터링 : 기능을 쉽게 추가하게 만들기

리패거링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다.

이 시점에 현재 코드를 살펴보면서, 구조를 살짝 바꾸면 다른 작업을 하기가 쉬워진다.

비슷하지만 리터럴 값 몇개만 다른 함수가 필요한 경우, 원본 함수를 복사해서 붙여넣는 방식으로 처리하면 나중에

새 기능을 약간 변형한 버전을 만들어야 할 때 번거로울 수 있다. 이럴 때는 리팩터링 모자를 쓰고 

함수 매개변수화하기 (11.2절)를 적용해야한다.

<br/>

버그를 잡을 때도 마찬가지다. 오류를 일으키는 코드가 세 곳에 복제되어 퍼져 있다면, 

우선 한곳으로 합치는 편이 작업하기에 훨씬 편하다. 또는 질의 코드에 섞여 있는 갱신 로직을 분리하면

두 작업이 꼬여서 생기는 오류를 크게 줄일 수 있다.

이처럼 준비를 위한 리팩터링으로 상황을 개선해놓으면 버그가 수정된 상태가 오래 지속될 가능성을 높이는 동시에,

같은 곳에서 다른 버그가 발생할 가능성을 줄여준다.


## 이해를 위한 리팩터링 : 코드를 이해하기 쉽게 만들기

코드를 수정하려면 먼저 그 코드가 하는 일을 파악해야 한다.

그 코드를 작성한 사람은 자신일 수도 있고 다른 사람일 수도 있다.

코드를 파악할 때마다 그 코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지는 없는지 찾아본다.

조건부 로직의 구조가 이상하지 않은지 살펴보기도 하고,

함수 이름을 잘못 정해서 실제로 하는 일을 파악하는 데 시간이 오래 걸리지 않는지 살펴본다.

이러한 리팩터링은 코드를 더 오래 보존할 수 있게 할 수 있다. 또한,

나중은 물론이고 지금 당장 효과를 보는 것도 있다.

코드를 분석할 때 리팩터링을 해보면, 그러지 않았더라면 도달하지 못했을 더 깊은 수준까지 이해하게 된다.

이해를 위한 리팩터링은 복잡한 코드 아래 숨어 있는 다양함을 발견할 수 있는 기회이다.

## 쓰레기 줍기 리팩터링

코드를 파악하던 중에 일을 비효율적으로 처리하는 모습을 발견할 때가 있다.

로직이 쓸데없이 복잡하거나, 매겨변수화한 함수 하나면 될 일을 거의 똑같은 함수 여러 개로 작성해놨을 수 있다.

이때 약간 절충을 해야 한다. 원래 하려던 작업과 관련 없는 일에 너무 많은 시간을 빼앗기긴 싫을 것이다.

그렇다고 쓰레기가 나뒹굴게 방치해서 나중에 일을 방해하도록 내버려두는 것도 좋지 않다.

간단히 수정할 수 있는 것은 즉시 고치고, 시간이 좀 걸리는 일은 짧은 메모만 남긴 다음, 하던 일을 끝내고 나서

처리 하면 좋다. 이것이 이해를 위한 리팩터링의 변경인 쓰레기 줍기 리팩터링 이다.

코드를 훑어볼 때마다 조금씩 개선하다 보면 결국 문제가 해결될 것이다.

리팩터링의 멋진 점은 각각의 작은 단계가 코드를 깨뜨리지 않는다는 사실이다.

그래서 작업을 잘게 나누면 몇 달에 걸쳐 진행하더라도 그 사이 한 순간도 코드가 깨지지 않기도 한다.

## 계획된 리팩터링과 수시로 하는 리팩터링

개발에 들어가기 전에 리팩터링 일정을 따로 잡아두지 않고, 

기능을 추가하거나 버그를 잡는 동안 리팩터링도 함께 진행한다.

리팩터링을 프로그래밍 과정에 자연스럽게 녹이는 것이다.

기능을 추가할 때든 버그를 잡을 때든, 리팩터링은 눈앞의 문제뿐 아니라 앞으로 할 작업에도 도움을 준다.

**리팩터링은 프로그래밍과 구분되는 별개의 활동이 아니다**

<br/>

**보기 싫은 코드를 발견하면 리팩터링하자. 그런데 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.**

<br/>

리팩터링은 과거에 저지른 실수를 바로잡거나 보기 싫은 코드를 정리하는 작업이라고 오해하기 쉽다.

보기 싫은 코드를 보면 리팩터링해야 함은 당연하지만, 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.

코드를 작성할때는 적절한 타협점이 필요하다. 예컨대 매개변수화하거나 개별 함수로 나누는 기준을 정한다.

어제는 적합했던 기준이 오늘 하는 다른 작업에는 맞지 않을 수 있다.

이렇게 상황이 변해 기준을 변경해야 할 때 코드가 이미 깔끔하다면 리팩터링하기 더 쉽다.

오랫동안 사람들은 소프트웨어 개발이랑 뭐가 '추가' 하는 과정으로 여겼다.

기능을 추가하다 보면 대개 새로운 코드를 작성해 넣게 된다. 하지만 뛰어난 개발자는 새 기능을 추가하기 쉽도록

코드를 '수정'하는 것이 그 기능을 가장 빠르게 추가하는 깅일 수 있음을 안다.

소프트웨어 개발을 끝이 있는 작업으로 보면 안 된다. 새 기능이 필요할 때마다 소프트웨어는 

이를 반영하기 위해 수정된다. 이때 새로 작성해 넣는 코드보다 기존 코드의 수정량이 큰 경우가 대체로 많다.

<br/> 

물론 계획된 리팩터링이 무조건 나쁘다는 말은 아니다. 그동안 리팩터링에 소홀했다면, 따로 시간을 내서 

새 기능을 추가하기 쉽도록 코드 베이스를 개선할 필요가 있다.

하지만, 계획된 리팩터링을 하게 되는 일은 최소한으로 줄여야 한다. 

리팩터링 작업 대부분은 드러나지 않게, 기회가 될 때마다 해야한다.

리팩터링은 기능 추가와 밀접하게 엮인 경우가 너무나 많기 때문에 굳이 나누는 것은 시간 낭비일 수 있다.

또한 해당 리팩터링을 하게 된 맥락 정보가 사라져서 왜 그렇게 수정했는지 이해하기 어려워진다.

**리팩터링 커밋을 분리한다고 해서 무조건 좋은 것은 아님을 명심해야한다.**

## 오래 걸리는 리팩터링

리팩터링은 대부분 몇 분안에 끝난다. 하지만 팀 전체가 달려들어도 몇 주는 걸리는 대규모 리팩터링도 있다.

라이브러리를 새 것으로 교체하는 작업일 수도 있고 일부 코드를 다른 팀과 공유하기 위해 컴포넌트로 빼는

작업일 수도 있다. 또는 골치 아픈 의존성을 정리하는 작업일 수도 있다.

하지만 **팀 전체가 리팩터링에 매달리는것은 회의적일 수도 있다.**

그보다는 주어진 문제를 몇 주에 걸쳐 조금씩 해결해가는 편이 효과적일 때가 많다.

누구든지 리팩터링해야 할 코드와 관련한 작업을 하게 될 때마다 원하는 방향으로 조금씩 개선하는 식이다.

리팩터링이 코드를 깨트리지 않는다는 장접을 활용하는 것이다.

일부를 변경해도 모든 기능이 할상 올바르게 동작한다. 예컨대 라이브러리를 교체할 때는 기존 것과 새 것

모두를 포용하는 추상 인터페이스부터 마련한다. 기존 코드가 이 추상 인터페이스를 호출하도록 만들고 나면

라이브러리를 훨씬 쉽게 교체할 수 있다.









